package com.gate.jvm.optimization;

/**
 * GC: Garbage Collector:垃圾回收
 * GC tuning: GC调优。
 *
 * Q:what is garbage：什么是垃圾
 * A:比如main方法里有一个变量，Object o = new Object()，new出来的Object在堆内存里占用了一片内存，
 *     在自己的内存空间里有一个成员变量，这个成员变量又指向了另外一个对象。在程序运行的过程中，如果引用
 *     不存在了，这个成员变量不指向另一个对象了，另一个对象就成为垃圾了。
 *   所谓的垃圾就是没有任何引用指向的对象，或者循环引用的多个对象，就是垃圾。
 *   Java只管new，占用内存。垃圾回收器会自动回收内存。
 *
 * Q:how to find it：怎么找到这个垃圾
 * A:1.reference count(引用计数):在每一个对象的脑袋上记一个数，来记录有多少引用来引用这个对象，
 *     当这个数字变成0的时候，也就是没有引用的时候，就定义它为垃圾。reference count不能解决循环引用产生的垃圾。
 *   2.root searching(根可达算法):当我们执行一个程序的时候，一个程序main()方法运行起来之后，相当于一个线程启动，
 *     线程启来后，在内存中是个线程栈，线程栈里的变量称之为根变量(GC Root),根变量一定是有用的，找出根变量在找出根
 *     变量引用的对象，就都是有用的对象。只要通过跟对象和跟对象引用找不到的对象，就称之为垃圾。
 *     哪些对象是根对象：Java的虚拟机栈，本地方法栈，运行时常量池，方法区里的静态引用，以及牵扯到的class的类对象。
 *     简而言之要运行程序的时候，这个程序必需的那些对象就称之为根对象。
 *     根对象：虚拟机栈中的引用的对象、类静态属性引用的对象、常量池引用的对象、本地方法栈中JNI的引用的对象。
 *
 * Q:GC algorithms：用什么算法进行垃圾回收
 * A:1.Mark-Sweep(标记-清除)：当我们找到哪些是垃圾后，就把它清除。清掉后这个垃圾对应的内存就可以使用了。
 *     通过跟对象找到能够链接到的对象标记为不可回收，链接不到的标记为可回收。再把可回收的变成空闲。
 *     算法相对简单，存活对象比较多的情况下效率较高；
 *     两边扫描，效率偏低，容易产生碎片。碎片化：比如两块内存中间回收了一个小内存，当放入新的大对象是时候放不进去。
 *   2.Copying(复制)：把内存分称两半，只用其中一半，这一半中如果找到不可回收对象，就直接把不可回收对象和它的引用复制到另一半内存，
 *     当把不可回收对象和其引用都复制到另一半内存后，之前那一半只剩下可回收的内存，就一次性回收了。
 *     适用于存活对象较少的情况，只扫描一次，效率提高，没有碎片；
 *     会造成空间浪费(要把内存分成两半)，移动复制对象需要调整对象的引用。
 *   3.Mark-Compact(标记-压缩)：当它找到这些垃圾之后，会把后面不可回收的复制到可回收的位置，这样就会把所有不可回收对象都复制到内存的最前面。
 *     一边找一边标记一边碎片化整理。碎片化整理在这里就是把不可回收对象复制到可回收对象的位置。
 *     不会产生碎片，不会将内存分称两半；
 *     扫描两次(第一次扫描，找出可用的，第二次扫描进行压缩)，需要移动对象，效率偏低。
 *
 * 由于各种各样的算法并不能达到一种算法适应多种情况，所以进行了一个分代的策略，来让GC的效率变高：
 * 分代垃圾收集器：
 *   在管理内存时会分成新生代和老年代。新生代和老年代比例默认1:3，也可以自己调。
 *   --Xmn设置新生代有多大，--Xms设置最大堆，--Xmx设置最小堆
 *   --XX:MaxTenuringThreshold是设置对象升入老年代的年龄的。
 *   新生代是新产生的对象往里装的区域，老年代是一直回收回收了很多次都没回收的对象。
 *   新生代中垃圾很多，非垃圾很少，老年代非垃圾很多，垃圾很少。
 *   大对象直接进入老年代，因为新生代可能装不下。如果老年代也装不下，就会内存溢出。
 *   老年代中的垃圾回收算法：Mark-Compact或者Mark-Sweep。
 *   新生代中的垃圾回收算法用：Copying。
 *   新生代区分称了三个区：
 *      1.eden:回收内存比较多，存活内存比较小，所以复制到s1里。
 *      2.survivor(s1):s1一般和s2之间来回复制，直到复制很多次也没回收的时候就放到老年代中。
 *      3.survivor(s2):s1一般和s2之间来回复制，直到复制很多次也没回收的时候就放到老年代中。
 *
 * 一个对象从出生到消亡：
 *   一个新对象会尝试在栈上去分配内存，分配不下进入Eden区，在Eden区里，如果在Eden区里不会被回收，进入S1区，
 *   S1区没有回收会跑到S1，对象如果一直不会收会一直在S1、S2之间来回复制。当这个对象年龄太大的时候(可以自己设置，
 *   就是很多次都没回收掉的对象)会进入到老年代。进入old区的年龄参数可以通过-XX:MaxTenuringThreshold配置。
 *
 * Q:GC的概念和触发GC的条件
 * A:GC的概念:
 *   1.MinorGC/YoungGC:新生代空间耗尽时触发。比如一直很快速的往新生代新建对象，内存就满了就会触发YGC。
 *   2.MajorGC/FullGC:在老年代无法继续分配空间时触发。当老年代触发FullGC的时候会同时进行新生代的GC，进行整体内存的回收。
 *   所谓的调优就是尽量不要触发FullGC，尽量减少YGC。
 *   调优的目的就是减少各个年代的GC频率。
 *
 * Q:常见的垃圾回收器。
 * A: // 1-6 是分代的垃圾回收器。
 *   1.Serial:单线程串行化。适用于新生代。
 *      会产生STW，但是产生STW的时间比较短。STW(stop-the-world)，当程序运行的时候，要进行垃圾回收时，会把所有的线程停掉，
 *      停在safe point(安全点)，然后单线程垃圾回收器运行，垃圾回收器运行完，程序会在safe point后面继续执行。
 *      单CPU下效率最高。
 *      为什么会产生STW，因为如果程序不停就进行垃圾回收，很可能在垃圾回收时标记的可回收对象一会会被线程用到，所以必须要停掉线程。
 *   2.SerialOld:单线程串行化。适用于老年代。
 *   3.ParNew:多线程。适用于新生代。
 *      它和ParallelScavenge区别不大，不同是它的主要功能是来配合CMS的。因为CMS某些阶段需要并发，ParNew进行了改进。
 *      ParNew和ParallelScavenge的区别：
 *          ParNew：响应时间优先，配合CMS；响应时间是STW的时间，越短越好。
 *          ParallelScavenge：吞吐量优先。吞吐量是单位时间内用户的线程执行时间 / 用户线程执行时间 + GC时间。比如JVM运行了10s，用户执行了9s操作，GC1s，那么吞吐量就是90%。
 *   4.ParallerOld:多线程。适用于老年代。
 *   5.ParallelScavenge:多线程。适用于新生代。
 *      会产生STW，运行在新生代，是copying算法。STW还是会产生，GC的时候需要停掉用户线程。然后并发执行GC，比单线程GC效率高。
 *   6.CMS:适用于老年代。
 *      CMS是在分代算法里最复杂的一个垃圾回收器。
 *      CMS(ConcurrentMarkSweep)并发的标记清除:并行是站在cpu的角度，并发是垃圾回收的线程和用户的线程是否在同时进行。
 *      CMS:当用户的线程正在执行时需要垃圾回收了，CMS会进行初始标记，初始标记会标记处根对象，标记处根对象后CMS会并发标记后面的垃圾，
 *          并发标记这些垃圾的时候不会影响用户的线程，它的算法核心就是在并发标记这里，这里不需要STW，在做这些并发标记的时候可能做错了
 *          因为没有STW，可能开始标记的可回收被并行的用户线程改掉了，这时CMS会进行重新标记，因为并发标记中可能大部分都标记对了，
 *          只有少部分标记错了，所以重新标记过程也不会很久。重新标记后CMS会进行并发清理。
 *          CMS是理解G1、ZGC、Shenandoah的基石。
 *          初始标记 -> 并发标记 -> 重新标记 -> 并发清理。
 *   新生代和老年代垃圾回收器配合使用：
 *      Serial - SerialOld.
 *      Serial - CMS.
 *      ParNew - CMS.
 *      ParNew - SerialOld.
 *      ParallelScavenge - SerialOld.
 *      ParallelScavenge - ParallerOld.
 *      CMS - SerialOld. CMS如果到最后配置不好了之后就会使用SerialOld。CMS一旦触发FullGC，算法用的是SerialOld。
 *        SerialOld是单线程，单线程触发FullGC回收是串行的时间是很久的。
 *   // 下面是不分代的垃圾回收器。
 *   7.ZGC:并发执行，10ms的间隔都不需要，适用于停顿时间特别短的程序。
 *   8.G1:
 *   9.Shenandoah:
 *   10.Epsilon:
 *
 * tuning：
 */
public class T01_JVMGC {
}
