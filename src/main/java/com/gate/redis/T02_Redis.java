package com.gate.redis;

/**
 * redis.cn：Redis中文网
 *
 * Redis是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。
 * 它支持多种类型的数据结构，如字符串（strings)、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）、bitmaps等。
 * 上面说的类型是Redis value的类型。Redis是 key-value存储的。
 * Redis内置了复制，LUA脚本，LRU驱动事件，事务和不同级别的磁盘持久化，并通过Redis哨兵和自动分区提供高可用性。
 *
 * Redis和memcached: memcached也是key-value的，但是memcached中的value没有类型的概念。
 * 如果客户端想通过一个缓存系统(key-value)的取回value中的某一个元素,如果是memcached，需要返回所有value里的数据到客户端，客户端还要有代码去对数据进行解析；
 * 而Redis对每种类型都有自己的解析方法。也就是计算向数据移动，不需要把数据全部返回到客户端再解析，而是把计算方法放在数据一端，只返回需要的数据。
 *
 * Q:Redis是单线程，那是如何保证并发的时候这么快的呢？
 * A:客户端的连接先打到linux的内核(kernel)，Redis进程和内核之间使用的是epoll，非阻塞多路复用的概念。
 *
 * epoll:eventpoll。
 *  计算机有内核，内核可以接到很多客户端连接，所有的连接肯定先到内核，一个连接是一个fd(文件编号符)，一个线程或者进程通过read来读取文件编号符。
 *  因为socket在这个时期是blocking的，在你read时数据包还没到的时候是阻塞的。这就是BIO时期。
 *  基于上面的情况，内核发生了跃迁变化，socket也可以是nonblock的，就可以有一个线程去执行那些并发请求，轮询发生在用户空间，属于同步非阻塞NIO。
 *  如果有1000个fd，代表用户进程轮询调用1000次kernel，这会带来成本问题。基于这种情况，内核增加了一个系统调用select，用户进程去调用select，传入1000个fds，
 *  内核去监控这些fds，将有数据的fds返回给线程，线程拿到这些fds，再去调用read这些fds。这样在系统调用上做的更精确。属于同步非阻塞，叫多路复用NIO。
 *  这种情况fds相关的数据传来传去也会使效率降低。
 *  基于上面的，在用户态和内核态之间加了一个共享空间mmap，内核和用户怎么用这个共享空间呢，共享空间里做了红黑树和链表。用户空间有1000个fds，把这些fds写进
 *  共享空间内，用户空间不再用维护这1000个fds，kernel监控这些fds，哪些有数据了将fds也放入内存空间，用户可以直接在内存空间中读取这些fds。
 *  这些都是JVM去调用的，我们的代码跑在JVM上，上面的用户也就是JVM。
 *
 * 零拷贝：
 *  在以前的情况下，读写一个文件是用户空间调用read(fd)方法调到内核，内核找到这个文件读取到内核空间，用户读取到用户空间，用户在通过write(fd)方法写到内核空间发出去。需要拷贝的过程。
 *  出现了零拷贝(sendfile(out,in))之后，用户调用sendfile()，内核读取文件到缓冲区，然后直接发出去。
 *
 */
public class T02_Redis {
}
